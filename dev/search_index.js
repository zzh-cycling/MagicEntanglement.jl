var documenterSearchIndex = {"docs":
[{"location":"#MagicEntanglement","page":"Home","title":"MagicEntanglement","text":"Documentation for MagicEntanglement.\n\n","category":"section"},{"location":"#MagicEntanglement.all_logical_paulis-Tuple{QuantumClifford.MixedDestabilizer}","page":"Home","title":"MagicEntanglement.all_logical_paulis","text":"all_logical_paulis(stab::MixedDestabilizer) -> Vector{PauliOperator}\n\nGenerate all 4^k logical Pauli operators for a stabilizer code with k logical qubits.\n\nGiven a stabilizer code with k logical qubits, there are 4^k logical Pauli operators corresponding to all combinations of I, X, Y, Z on each logical qubit. These operators form a basis for the logical operator algebra M.\n\nImportant: Logical operators are defined as equivalence classes modulo the stabilizer group. That is, if L is a logical operator and S is any stabilizer, then L*S is an  equivalent logical operator. This function returns one representative from each  equivalence class (the \"bare\" logical operators from logicalxview and logicalzview).\n\nFor finding logical operators supported on a subregion, use subregion_logical_paulis which searches for representatives in each equivalence class that have the desired support.\n\nThe encoding is:\n\n0 → I (identity)\n1 → X (logical X)  \n2 → Y (logical Y = iXZ)\n3 → Z (logical Z)\n\nArguments\n\nstab::MixedDestabilizer: A MixedDestabilizer representing the stabilizer code\n\nReturns\n\nVector{PauliOperator}: All 4^k logical Pauli operators (one representative per class)\n\nExample\n\njulia> s = S\"XXXX\n             ZIZI\n             IZIZ\"  # [[4,1,2]] code\njulia> stab = MixedDestabilizer(s)\njulia> ops = all_logical_paulis(stab)\njulia> length(ops)  # 4^1 = 4\n4\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.compute_logical_density_matrix-Tuple{QuantumClifford.Stabilizer, Vector{Int64}, Vector{<:QuantumClifford.Stabilizer}, Vector{<:Number}}","page":"Home","title":"MagicEntanglement.compute_logical_density_matrix","text":"compute_logical_density_matrix(S::Stabilizer, A::Vector{Int}, \n                               states::Vector{<:Stabilizer}, \n                               coeffs::Vector{<:Number}) -> Matrix{ComplexF64}\n\nCompute the logical density matrix ρ_A for subsystem A.\n\nGiven a state |Ψ⟩ = Σj cj |ψj⟩ where |ψj⟩ are stabilizer states in the code space defined by S, compute the reduced density matrix on the logical subspace accessible from region A.\n\nThe density matrix is computed via Pauli tomography:     ρA = (1/d) ΣP ⟨Ψ|P|Ψ⟩ P\n\nwhere P ranges over all logical Paulis supported on A, and d = dim(M_A).\n\nArguments\n\nS::Stabilizer: The common stabilizer group\nA::Vector{Int}: Subsystem qubit indices\nstates::Vector{Stabilizer}: The stabilizer states |ψ_j⟩\ncoeffs::Vector{Number}: The coefficients c_j\n\nReturns\n\nMatrix{ComplexF64}: The logical density matrix ρ_A\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.compute_logical_entropy-Tuple{QuantumClifford.Stabilizer, Vector{Int64}, Vector{<:QuantumClifford.Stabilizer}, Vector{<:Number}}","page":"Home","title":"MagicEntanglement.compute_logical_entropy","text":"compute_logical_entropy(S::Stabilizer, A::Vector{Int}, \n                       states::Vector{<:Stabilizer}, \n                       coeffs::Vector{<:Number}) -> Float64\n\nCompute the von Neumann entropy S(ρ_A) of the logical density matrix.\n\nThis implements Algorithm 1 from the paper \"An efficient algorithm to compute  entanglement in states with low magic\" (arXiv:2510.06318).\n\nAlgorithm Overview\n\nGenerate all 4^k logical Pauli operators from the stabilizer code\nFilter to keep only those supported on subsystem A (forming M_A)  \nCompute expectation values ⟨Ψ|P|Ψ⟩ for each P ∈ M_A\nReconstruct ρ_A via Pauli tomography\nDiagonalize and compute entropy\n\nArguments\n\nS::Stabilizer: The common stabilizer group defining the code\nA::Vector{Int}: Qubit indices defining subsystem A\nstates::Vector{Stabilizer}: The stabilizer states |ψ_j⟩ in superposition\ncoeffs::Vector{Number}: Coefficients cj where |Ψ⟩ = Σ cj |ψ_j⟩\n\nReturns\n\nFloat64: The von Neumann entropy S(ρA) = -Tr(ρA log₂ ρ_A)\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.expect_pauli-Tuple{QuantumClifford.PauliOperator, QuantumClifford.MixedDestabilizer}","page":"Home","title":"MagicEntanglement.expect_pauli","text":"expect_pauli(P::PauliOperator, stab::MixedDestabilizer) -> ComplexF64\n\nCompute ⟨ψ|P|ψ⟩ for a Pauli operator on a state represented by MixedDestabilizer.\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.expect_pauli-Tuple{QuantumClifford.PauliOperator, QuantumClifford.Stabilizer}","page":"Home","title":"MagicEntanglement.expect_pauli","text":"expect_pauli(P::PauliOperator, S::Stabilizer) -> ComplexF64\n\nCompute the expectation value ⟨ψ|P|ψ⟩ for a Pauli operator P on stabilizer state |ψ⟩.\n\nEfficient Implementation using Stabilizer Formalism:\n\nFor a Pauli operator P on a stabilizer state |ψ⟩ defined by stabilizer group S:\n\nIf P anticommutes with any stabilizer generator: ⟨ψ|P|ψ⟩ = 0\nIf P is in the stabilizer group S: ⟨ψ|P|ψ⟩ = ±1 or ±i (determined by the phase)\nIf P commutes with S but is not in S: ⟨ψ|P|ψ⟩ = 0 (P is a non-trivial logical operator)\n\nThis implementation has complexity O(n³) where n is the number of qubits, avoiding the exponential cost of state vector computation.\n\nArguments\n\nP::PauliOperator: The Pauli operator\nS::Stabilizer: The stabilizer state (must be full rank for pure state)\n\nReturns\n\nComplexF64: The expectation value\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.find_minimal_support_representative-Tuple{QuantumClifford.PauliOperator, QuantumClifford.MixedDestabilizer, Vector{Int64}}","page":"Home","title":"MagicEntanglement.find_minimal_support_representative","text":"find_minimal_support_representative(L::PauliOperator, stab::MixedDestabilizer, A::Vector{Int}) -> Union{PauliOperator, Nothing}\n\nFind a representative of the logical operator L (modulo stabilizers) that is  supported only on subsystem A, if one exists.\n\nThis uses Gaussian elimination on the stabilizer group restricted to the complement  of A to \"clean\" the logical operator.\n\nAlgorithm\n\nLet Ā = complement of A (qubits outside A)\nFor each stabilizer generator Si, check if multiplying L by Si reduces support on Ā\nUse Gaussian elimination to systematically remove support on Ā\n\nReturns\n\nPauliOperator: A representative supported on A, or\nnothing: If no such representative exists\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.is_in_stabilizer_group-Tuple{QuantumClifford.PauliOperator, QuantumClifford.MixedDestabilizer}","page":"Home","title":"MagicEntanglement.is_in_stabilizer_group","text":"is_in_stabilizer_group(P::PauliOperator, stab::MixedDestabilizer) -> Tuple{Bool, ComplexF64}\n\nCheck if Pauli operator P is in the stabilizer group, and if so, return its phase.\n\nUses the rowdecompose-like approach: if P can be written as a product of stabilizers, it's in the group.\n\nReturns\n\n(true, phase) if P is in the stabilizer group with the given phase factor\n(false, 0) if P is not in the stabilizer group\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.is_supported_on-Tuple{QuantumClifford.PauliOperator, Vector{Int64}}","page":"Home","title":"MagicEntanglement.is_supported_on","text":"is_supported_on(P::PauliOperator, A::Vector{Int}) -> Bool\n\nCheck if Pauli operator P is fully supported on subsystem A,  i.e., P acts as identity on all qubits outside A.\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.logical_pauli_to_matrix-Tuple{QuantumClifford.PauliOperator, Vector{QuantumClifford.PauliOperator}, Int64}","page":"Home","title":"MagicEntanglement.logical_pauli_to_matrix","text":"logical_pauli_to_matrix(P::PauliOperator, basis::Vector{PauliOperator}, dim::Int) -> Matrix{ComplexF64}\n\nConvert a physical Pauli operator (representing a logical operator) to its  logical qubit matrix representation.\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.pauli_support-Tuple{QuantumClifford.PauliOperator}","page":"Home","title":"MagicEntanglement.pauli_support","text":"pauli_support(P::PauliOperator) -> Vector{Int}\n\nReturn the support of a Pauli operator, i.e., the set of qubit indices where P acts non-trivially (not identity).\n\nExample\n\njulia> pauli_support(P\"_XY_Z\")\n[2, 3, 5]\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.pauli_to_matrix-Tuple{QuantumClifford.PauliOperator}","page":"Home","title":"MagicEntanglement.pauli_to_matrix","text":"pauli_to_matrix(P::PauliOperator) -> Matrix{ComplexF64}\n\nConvert a Pauli operator to its 2^n × 2^n matrix representation.\n\nArguments\n\nP::PauliOperator: n-qubit Pauli operator\n\nReturns\n\nMatrix{ComplexF64}: The 2^n × 2^n matrix representation\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.paulis_equivalent-Tuple{QuantumClifford.PauliOperator, QuantumClifford.PauliOperator}","page":"Home","title":"MagicEntanglement.paulis_equivalent","text":"paulis_equivalent(P1::PauliOperator, P2::PauliOperator) -> Bool\n\nCheck if two Pauli operators have the same X and Z bits (ignoring phase).\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.stabilizer_inner_product_with_pauli-Tuple{QuantumClifford.Stabilizer, QuantumClifford.PauliOperator, QuantumClifford.Stabilizer}","page":"Home","title":"MagicEntanglement.stabilizer_inner_product_with_pauli","text":"stabilizer_inner_product_with_pauli(ψ1::Stabilizer, P::PauliOperator, ψ2::Stabilizer) -> ComplexF64\n\nCompute ⟨ψ1|P|ψ2⟩ for two stabilizer states and a Pauli operator.\n\nUses the fact that P|ψ2⟩ is also a stabilizer state (up to phase),  and the inner product of two stabilizer states is efficiently computable.\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.stabilizer_state_vector-Tuple{QuantumClifford.Stabilizer}","page":"Home","title":"MagicEntanglement.stabilizer_state_vector","text":"stabilizer_state_vector(S::Stabilizer) -> Vector{ComplexF64}\n\nCompute the state vector representation of a stabilizer state. The stabilizer state |ψ⟩ is the unique state (up to phase) satisfying g|ψ⟩ = |ψ⟩ for all g ∈ S.\n\nWarning\n\nThis function has exponential complexity in the number of qubits and should only be used for small systems (n ≤ 15).\n\n\n\n\n\n","category":"method"},{"location":"#MagicEntanglement.subregion_logical_paulis-Tuple{QuantumClifford.MixedDestabilizer, Vector{Int64}}","page":"Home","title":"MagicEntanglement.subregion_logical_paulis","text":"subregion_logical_paulis(stab::MixedDestabilizer, A::Vector{Int}) -> Vector{PauliOperator}\n\nGet all logical Pauli operators that have a representative supported only on subsystem A.\n\nThis function finds, for each of the 4^k logical operator equivalence classes,  whether there exists a representative (logical operator times stabilizers) that  is fully supported on the subsystem A. These operators form the subalgebra M_A ⊂ M.\n\nAlgorithm\n\nFor each bare logical operator L:\n\nFind if there exists stabilizers S₁, S₂, ... such that L * S₁ * S₂ * ... is supported on A\nThis is done via Gaussian elimination over GF(2)\n\nArguments\n\nstab::MixedDestabilizer: The stabilizer code\nA::Vector{Int}: Qubit indices defining subsystem A\n\nReturns\n\nVector{PauliOperator}: Representatives of logical operator classes supported on A\n\nExample\n\njulia> s = S\"XXXX\n             ZIZI\n             IZIZ\"  # [[4,1,2]] code\njulia> stab = MixedDestabilizer(s)\njulia> sub_ops = subregion_logical_paulis(stab, [1, 2])\njulia> P\"ZZ__\" in sub_ops  # Should find ZZ on qubits 1,2\ntrue\n\n\n\n\n\n","category":"method"}]
}
